## Netty_PooledByteBuf_4.PoolChunkList

### 一. 干什么?

1. 按楼层下的空置率来进行分级管理, 大远看去一幢楼, 最空旷的楼层在最下面, 最拥挤的楼层在最上面.  
2. 楼层所属的分级是变化的, 空置率变化后, 会在不同的分级间游走. 没血了就回家, 有血了就往上冲.



### 二. 打算怎么干? 

1. 通过定义不同的空置率级别(min, max), 将整个楼分成不同的级别, 第个级别(PoolChunkList)下的空置率都在(min, max)范围内.

2. 随着楼层中空间的分配与回收, 空置率发生变化, 判断是否在不同级别(PoolChunkList)间是升还是降.

   


### 三. 具体实现:

1. #### 先看下初始化方法与数据结构:

   > ![PoolChunkList初始化及数据结构](/Users/dm/Documents/finup_codes/github/Reading-Netty-SourceCode/netty_4.1.63/images/3.PooledByteBufAllocator/2.DataStructure-5.PoolChunkList.png)
   >
   > - 图中标号: **1**. 属于那幢楼(arena).
   >
   > - 图中标号: **2**. 最高的那一级(nextList)是什么?
   >
   > - 图中标号: **3, 4**. 闲置率的边界的百分比(minUsage, maxUsage). 
   >
   > - 图中标号: **5**. 该分级下最大能满足的空间分配是多少(maxCapacity). 闲置率边界是用来进行分级管理的, maxCapacity表示的是可分配空间, 有可能分配完了, 会进行跳级.
   >
   > - 图中标号: **6, 7**. 计算闲置的边界字节数.
   >
   > - 图中标号: **11**. 一幢楼的分级管理(PoolArena), 从qInit到q100分了6级来管理. 1-5表示随着分配, 楼层的空置率的变化及在不同的分级(PoolChunkList)内上升, 6-9表示随着空间的释放, 空置率越来越高, 在不同的分级中的下降. 
   >
   >   **这里要注意:** 10.free, 因为q000的prev是空的, 所以如果楼层如果空置超过q000的freeMaxThreshold, 16777215----15.9M, 也就是16M空间都是空置时, 该楼层不会下降到qInit, 而是直接从管理分级中移除了. 
   >
   >   | 分级  |  minUsage   |  maxUsage  |   freeMinThreshold   |  freeMaxThreshold   |    maxCapacity    |
   >   | :---: | :---------: | :--------: | :------------------: | :-----------------: | :---------------: |
   >   | qInit | -2147483648 |     25     |  12750684----12.1M   | 2147483647----2048M | 16609443----15.8M |
   >   | q000  |      1      |     50     |   8556380----8.15M   |  16777215----15.9M  | 16609443----15.8M |
   >   | q025  |     25      |     75     |   4362076----4.15M   |  12750684----12.1M  |  12582912----12M  |
   >   | q050  |     50      |    100     |          0           |  8556380----8.15M   |   8388608----8M   |
   >   | q075  |     75      |    100     |          0           |  4362076----4.15M   |   4194304----4M   |
   >   | q100  |     100     | 2147483647 | -2147483648----2048M |          0          |         0         |
   
2. 