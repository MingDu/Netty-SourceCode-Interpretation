## Netty_PooledByteBuf_3.PoolChunk

### 一. 干什么?

​	PoolChunk 是来管理一个楼层中的房间的, 就像个楼主. 概括起来如下: 

1. 根据面积需求, 是给分配独立的区域还是共享区域.

2. 不管是独立还是共享区域下面积的分配与回收.

3. 管理的面积这么大, 怎么样可以让分配与回收的效率更高. 

   

### 二. 打算怎么干? 

1. 根据设定的阀值, 来区分是分配独立区域还是共享区域.

2. 对外提供统一接口进行面积的分配与回收.

3. 独立区域和共享区域都有唯一的门牌号并记录在案, 直接在账本上进行登入登出.

   

### 三. 具体实现:

1. #### 是分配独立区域还是共享区域?
   
   - 需要的面积 <= 16K + 12K (28K)时, 跟其它人一起共享, 在*PoolSubpage*里. 
   - \> 28K时, 大客户, 给独立的连续房间, 在*Run*里. 
   
    ```mermaid
    graph TD
    A[客户来啦!] 
        A --> C{您需要多大空间?}
        C -->|<= 28K| D[共享区域]
        C -->|> 28K| E[独享空间]
    style A fill:pink,stroke:#333,stroke-width:1px    
    style C fill:#bbf,stroke:#f66,stroke-width:1px,color:#fff,stroke-dasharray: 4 8
    style D fill:orange,stroke:#333,stroke-width:1px  
    style E fill:,stroke:#333,stroke-width:1px 
    ```
   
2. #### 分配与回收之前, 先来看一下PoolChunk初始化的数据结构.

    ##### PoolChunk数据结构: ![PoolChunk数据结构](./images/3.PooledByteBufAllocator/2.DataStructure-2.1.PoolChunk.png)

    1. ##### 构造方法初始化过程:

       > - 图中标号: **1** , <u>arena</u>该楼层在那一幢建筑内.
       >
       > - 图中标号: **2**, <u>memory</u> 对应的内存对象.
       >
       > - 图中标号: **3**, <u>pageSize</u> 一个房间有多大, 这里是8K.
       >
       > - 图中标号: **4** , <u>chunkSize</u> *PoolChunk* 对应的楼层有多大面积.
       >
       > - 图中标号: **5**, <u>freeBytes</u> 还有多少面积是可以分配的.
       >
       > - 图中标号: **6**, <u>runsAvail</u> 对应的 *LongPriorityQueue*[40:**maxPageIdx**] 数组, 对应的数组大小为*SizeClasses*中的<u>pageIdx2sizeTab</u> 数据的大小.
       >
       > - 图中标号: **7**, *LongPriorityQueue*是提供排序的队列, [LongPriorityQueue的详细介绍](./3.1.LongPriorityQueue.html).
       >
       > - 图中标号: **9**, <u>runsAvailMap</u> 存放的是空闲房间的起始编号. 
       >
       > - 图中标号: **10**, <u>subpages</u>: *PoolSubpage*[2048] 中存放所有共享区域对象PoolSubpage, 只是这里按房间数计算的subpages数组大小, 但并不是每个数组的值都会是*PoolSubapge*对象, 也就是这个数组在大对象的场景中会有相当多的部分不会被填满. 
       >
       > - 图中标号: **11**, 初始化的<u>handle</u>, 表明当前的*PoolChunk*的一个空闲的空间.
       >
       > - 图中标号: **12**, 将初始化的<u>handle</u>更新到管理信息中, 如: <u>runsAvail</u>, <u>runsAvailMap</u>. 
       >
       > - 图中标号: **13**, <u>handle</u>由一个long来表示, 将long中的64个bit位划分成了四个部分. 用来标识已经分配的空间或者空置的空间.
       >
       >   - 各个部分的信息:
       >
       >     |     Bit 位     |                    源码标识                    |       含义       |
       >     | :------------: | :--------------------------------------------: | :--------------: |
       >     | 0-31, 共 32bit | bitmapIdx of subpage, zero if it's not subpage |    房间标号,     |
       >     |  32, 共 1bit   |                   isSubpage                    |  是否是共享区域  |
       >     |  33, 共 1bit   |                     isUsed                     |   是否已经分配   |
       >     | 34-48, 共15bit |                number of pages                 | 连续的房间有几间 |
       >     | 49-63, 共15bit |            page offset in the chunk            |   从第几间开始   |
       >
       >   - 例如: 
       >
       >     |                            handle                            |                             说明                             |
       >     | :----------------------------------------------------------: | :----------------------------------------------------------: |
       >     | 0{11}_**0000** - 0{11}\_**0100** - **10** - 0{24}\_0000\_0000 | 0{11}\_**0000** -- 从第0个房间开始, 0{11}\_**0100** -- 连续4个房间, <br />**10** -- 处于使用状态, 独立区域. |
       >     | 0{11}\_**0100** - 0{11}_**0010** - **00** - 0{24}\_0000\_0000 | 0{11}\_**0100** -- 从第4个房间开始, 0{11}\_**0010** -- 连续2个房间, <br />**00** -- 处于空置状态. |
       >     | 0{11}\_**1001** - 0{11}_**0001** - **11** - 0{24}\_**0100\_0001** | 0{11}\_**1001** -- 从第9个房间开始, 0{11}\_**0001** -- 连续1个房间, <br />**11** -- 处于使用状态, 共享区域, 共享区域中的第1排第一个座位. |
       >     | 0{11}_**0001_0101** - 000\_**0111_1110_1011** - **00** - 0{32} | 0{11}_**0001_0101** -- 从第21个房间开始, 000\_**0111_1110_1011** -- 连续2027个房间, <br />**00** -- 处于空置状态. |
       
    2. ##### 管理信息: 
    
       > - 图中标号: **101**, 将真正分配的内存空间(<u>memory</u>)按房间进行划分, 每一个房间给一个门牌号, 从0开始, 默认是到2047号.
       >
       > - 图中标号: **102**, <u>runsAvail</u>中存放连续房间的信息. 先根据连续房间的个数查找对应的runsAvail的index下标, 然后将描述这个区域的handle值放在index下标对应的*LongPriorityQueue*中.
       >
       >   - <u>runsAvail</u>每个index对应的连续房间数(pages)是一个区间(range), 
       >
       >     | runsAvail index | 对应连续pages, 表示最小有多少个连续房间. |
       >     | :-------------: | :--------------------------------------: |
       >     |        3        |             pages >= 4 & < 5             |
       >     |        8        |            pages >= 10 & < 12            |
       >     |       38        |          pages >= 1792 & < 2048          |
       >     |       39        |               pages = 2048               |
       >
       >   - <u>runsAvail</u>只存放空置房间的信息, 按连续房间的大小, 对应存放在index下标对应的*LongPriorityQueue*中. 例如图中: 已经<u>占用</u>的房间分别是: <u>0 - 3</u> -- 分配成<u>独立</u>区域. 房间 <u>6, 9, 12, 18</u> 被分配为<u>共享</u>区域.空置的房间**4-5**, **7-8**, **10-11**, **19-2047** .
       >
       >     |       空置房间(起 止)       | 空置房间数 | 对应的runsAvail.index |                    handle标识                     |
       >     | :-------------------------: | :--------: | :-------------------: | :-----------------------------------------------: |
       >     |  4 - 5, 图中标号: **103**   |     2      |           1           |       0{11}\_0100 - 0{11}_0010 - 00 - 0{32}       |
       >     |  7 - 8, 图中标号: **103**   |     2      |           1           |       0{11}\_0111 - 0{11}_0010 - 00 - 0{32}       |
       >     | 10 - 11, 图中标号: **103**  |     2      |           1           |       0{11}\_1010 - 0{11}_0010 - 00 - 0{32}       |
       >     |  13-17, 图中标号: **104**   |     5      |           4           |       0{11}\_1101 - 0{11}_0101 - 00 - 0{32}       |
       >     | 21 -2047, 图中标号: **105** |    2027    |          38           | 0{11}_0001_0101 - 000_0111_1110_1011 - 00 - 0{32} |
       >
       > 
       >
       > 3. 图中标号: **106**, <u>runsAvailMap</u>: *LongLongHashMap* 存放的是空置空间的起止信息. 例如:
       >
       >    | Key  |                         Key 说明                         |                Value -- handle信息                |
       >    | :--: | :------------------------------------------------------: | :-----------------------------------------------: |
       >    |  4   |    图中标号: **107**, 空置空间 4 - 5, 从门牌号: 4开始    |       0{11}\_0100 - 0{11}_0010 - 00 - 0{32}       |
       >    |  5   |    图中标号: **108**, 空置空间 4 - 5, 到门牌号: 5结束    |       0{11}\_0100 - 0{11}_0010 - 00 - 0{32}       |
       >    |      |                                                          |                                                   |
       >    |  21  | 图中标号: **109**, 空置空间 21 -2047, 从门牌号: 21个开始 | 0{11}_0001_0101 - 000_0111_1110_1011 - 00 - 0{32} |
       >    | 2047 | 图中标号: **110**, 空置空间 21 -2047, 到门牌号: 2047结束 | 0{11}_0001_0101 - 000_0111_1110_1011 - 00 - 0{32} |
       >
       >    注: runsAvailMap的一个应用场景是查找与当前的区域相临的区域是空置还是已经分配的, 用在区域中.
       >
       > 4. 图中标号: **111**, subpages: PoolSubpage[2048], 这里按房间的个数来初始化数组, 实际上可能有很多个下标对应的null值. 当一个共享区域(*PoolSubpage*)被分配时, 可能是多个房间划分到这个共享区域下, 共享区域开始于那个门牌号, 那么就存放在门牌号对应的index下标下. 例如:
       >
       >    | <u>subpages</u>.index |                     对应共享区域                      |             *PoolSubpage*             |
       >    | :-------------------: | :---------------------------------------------------: | :-----------------------------------: |
       >    |           6           |  图中标号: **112**, 共享区域 6 - 6, 从门牌号: 6开始   |    每个elemSize为32, 共享区域为8K     |
       >    |           9           |  图中标号: **113**, 共享区域 9 - 9, 从门牌号: 9开始   |   每个elemSize为1024, 共享区域为8K    |
       >    |          18           | 图中标号: **114**, 共享区域 18 - 20, 从门牌号: 18开始 | 每个elemSize为1024 * 3, 共享区域为24K |
    
3. 方法实现:

    空间分配: ![PoolChunk allocate](./images/3.PooledByteBufAllocator/1.MainFlow-4.1.PoolChunk_allocate.png)

    1. <u>allocate</u>() 方法, 图中标号: **1**, <u>allocate</u>()方法是*PoolChunk*的空间分配的入口. 其中示例<u>allocate</u>(buf,18: reqCapacity,1: sizeIdx, threadCache) 表示需要的空间是18, 对应的标准化后的分档sizeIdx 是1(对应32字节).

       > - 图中标号: **2**, sizeId <= <u>arena.smallMaxSizeIdx</u>. 其中<u>sizeId</u>是*SizeClasses*中的<u>sizeClasses</u>数组的下标. arena.smallMaxSizeIdx是独立空间与共享空间的分界线, 默认值38对应28K空间.
       > - 图中标号: **3**, 在共享区域中分配一个位置. 调用<u>allocateSubpage</u>()方法.
       > - 图中标号: **4**, 分配独立空间, 从runSize 为从*SizeClasses*.<u>sizeIdx2sizeTab</u>[] 中获取sizeIdx对应的空间大小, 是page的倍数.
       > - 图中标号: **5**, <u>allocateRun</u>()分配独立的空间.
       > - 图中标号: **6**, 如果<u>handle</u> < 0表示没有分配成功.
       > - 图中标号: **7**, 分配空间后, <u>initBuf</u>()对空间进行初始化的操作.

    2. allocateRun() 方法, 图中标号: **11**, 分配独立的空间, 为page的倍数. 图中示例runSize为8192, 一个page.

       > - 图中标号: **12**, <u>pages</u>为计算需要几个房间. 示例为pages = 1;
       > - 图中标号: **13**, <u>pageIdx</u> 为根据需要房间数查找*SizeClasses*.<u>pageIdx2sizeTab</u>[]中对应的index, 取大不取小. 示例pageIdx为0.
       > - 图中标号: **14**, 因为要对<u>runsAvail</u>进行更改, 所以对<u>runsAvail</u>加锁.
       > - 图中标号: **15**, runFirstBestFit()根据需要的房间数, 从闲置空间里找到最合适的那一个来进行切割.  图中示例queueIdx 为39, 因为这是一个全闲置的PoolChunk, 39表示连续的空置房间2048个.
       > - 图中标号: **16**, queueIdx == -1; 表示没有找到能满足需求的空间. 
       > - 图中标号: **17, 18, 19**, 从runsAvail[queueIdx] 中取第一个可以满足需求的"待切割空间".  将把这个待切割空间的起止房间信息从runsAvailMap中清除掉先. 示例中的"待切割空间"为2048, 起止房间门牌号为0 -> 2047.
       > - 图中标号: **20**, 划分空间, 就像块蛋糕(pages)一样, 如果切完了还有剩余, 再还回去. 把切下来的蛋糕放盘子里,handle =  0000 - 000_0000_0000_0001 - 10 << 32.
       > - 图中标号: **21, 22**, 看看切了多少蛋糕下来, 总的还剩多少.
       > - 图中标号: **23**, 把切下来的蛋糕端上来. 

    3. allocateSubpage() 方法, 图中标号: **31**, 在共享区域内分配空间.

       > - 图中标号: **32**, PoolArena中针对每种sizeIdx都维护了一个单独的队列, head为队列的头. 详情请看PoolArena.
       >
       > - 图中标号: **33**, sync(head) 因为要对队列进行更改, 所以加锁.
       >
       > - 图中标号: **34**, calculateRunSize() 取elemSize(需求面积的标准化)与pageSize的最小公倍数, 以保证共享区域恰好能放下那么多椅子, 不多不少.
       >
       >   | 需要的面积 | elemSize: 标准化后的需求面积 | pageSize: 房间面积 | runSize: 最小公倍数 |
       >   | :--------: | :--------------------------: | :----------------: | :-----------------: |
       >   |     16     |              16              |        8192        |        8192         |
       >   |     18     |              32              |        8192        |        8192         |
       >   |   16 * 7   |            16 * 7            |        8192        |      8192 * 7       |
       >
       > - 图中标号: **35**, 根据需要的runSize, 划分独立区域, 划分完成后返回runHandle. 
       >
       > - 图中标号: **36**, 划分的区域从那个门牌号开始.
       >
       > - 图中标号: **37**, 标准化后的需求面积 elemSize.
       >
       > - 图中标号: **38**, 划分的区域由几个房间组成.
       >
       > - 图中标号: **39**, 基于划分好的区域创建共享区域对象PoolSubpage.
       >
       > - 图中标号: **40**, 
       >
       >   ```java
       >   subpages[runOffset] = subpage; //将新创建的subpage对象按起始的门牌号作下标放在subpages数组中.
       >   ```
       >
       > - 图中标号: **41**, 在共享区域subpage里分配需要的面积.

    4. runFirstBestFit(), 图中标号: **51**. 从空闲的房间里找那个最合适能满足需求的. 

       > - 图中标号: **52**. 
       >
       >   ```java
       >   if(freeBytes == chunkSize) //讨巧的判断与返回.如果整个楼层都是空闲的, 直接返回. 
       >   ```
       >
       > - 图中标号: **53, 54, 55, 56**, 
       >
       >   ```java
       >   for (int i = pageIdx; i < arena.nPSizes; i++) {// 从pageIdx开始, 由小到大的连续空间进行判断.例如, 要连着的4个房间, 如果连着的4个房间没有现成的, 那就看看连着5个房间的有现成的吗, 如果有就从5个房间里分4个房间出来, 如果没有, 就看连着6个房间的有现成的吗.  
       >       LongPriorityQueue queue = runsAvail[i];
       >       if (queue != null && !queue.isEmpty()) { //有现成的吗?
       >           return i;
       >       }
       >   }
       >   ```
       >
       > - 图中标号: **57**, 有可能楼里有的房间, 但都是小户型(相连的房间数小), 那只能到其它楼里看看了.

    5. splitLargeRun(), 图中标号: **61**. 把大的连续房间按需求进行拆分.

       > - 图中标号: **52**. 

    6. 

[TOC]

