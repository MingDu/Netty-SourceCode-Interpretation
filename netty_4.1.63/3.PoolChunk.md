## Netty_PooledByteBuf_3.PoolChunk

### 一. 干什么?

​	PoolChunk 是来管理一个楼层中的房间的, 就像个楼主. 概括起来如下: 

1. 根据面积需求, 是给分配独立的区域还是共享区域.

2. 不管是独立还是共享区域下面积的分配与回收.

3. 管理的面积这么大, 怎么样可以让分配与回收的效率更高. 

   

### 二. 打算怎么干? 

1. 根据设定的阀值, 来区分是分配独立区域还是共享区域.

2. 对外提供统一接口进行面积的分配与回收.

3. 独立区域和共享区域都有唯一的门牌号并记录在案, 直接在账本上进行登入登出.

   

### 三. 具体实现:

1. #### 是分配独立区域还是共享区域?
   
   - 需要的面积 <= 16K + 12K (28K)时, 跟其它人一起共享, 在*PoolSubpage*里. 
   - \> 28K时, 大客户, 给独立的连续房间, 在*Run*里. 
   
    ```mermaid
    graph TD
    A[客户来啦!] 
        A --> C{您需要多大空间?}
        C -->|<= 28K| D[共享区域]
        C -->|> 28K| E[独享空间]
    style A fill:pink,stroke:#333,stroke-width:1px    
    style C fill:#bbf,stroke:#f66,stroke-width:1px,color:#fff,stroke-dasharray: 4 8
    style D fill:orange,stroke:#333,stroke-width:1px  
    style E fill:,stroke:#333,stroke-width:1px 
    ```
   
2. #### 分配与回收之前, 先来看一下PoolChunk初始化的数据结构.

    ##### PoolChunk数据结构: ![PoolChunk数据结构](./images/3.PooledByteBufAllocator/2.DataStructure-2.1.PoolChunk.png)

    1. ##### 构造方法初始化过程:

       > - 图中标号: **1** , <u>arena</u>该楼层在那一幢建筑内.
       >
       > - 图中标号: **2**, <u>memory</u> 对应的内存对象.
       >
       > - 图中标号: **3**, <u>pageSize</u> 一个房间有多大, 这里是8K.
       >
       > - 图中标号: **4** , <u>chunkSize</u> *PoolChunk* 对应的楼层有多大面积.
       >
       > - 图中标号: **5**, <u>freeBytes</u> 还有多少面积是可以分配的.
       >
       > - 图中标号: **6**, <u>runsAvail</u> 对应的 *LongPriorityQueue*[40:**maxPageIdx**] 数组, 对应的数组大小为*SizeClasses*中的<u>pageIdx2sizeTab</u> 数据的大小.
       >
       > - 图中标号: **7**, *LongPriorityQueue*是提供排序的队列, [LongPriorityQueue的详细介绍](./3.1.LongPriorityQueue.html).
       >
       > - 图中标号: **9**, <u>runsAvailMap</u> 存放的是空闲房间的起始编号. 
       >
       > - 图中标号: **10**, <u>subpages</u>: *PoolSubpage*[2048] 中存放所有共享区域对象PoolSubpage, 只是这里按房间数计算的subpages数组大小, 但并不是每个数组的值都会是*PoolSubapge*对象, 也就是这个数组在大对象的场景中会有相当多的部分不会被填满. 
       >
       > - 图中标号: **11**, 初始化的<u>handle</u>, 表明当前的*PoolChunk*的一个空闲的空间.
       >
       > - 图中标号: **12**, 将初始化的<u>handle</u>更新到管理信息中, 如: <u>runsAvail</u>, <u>runsAvailMap</u>. 
       >
       > - 图中标号: **13**, <u>handle</u>由一个long来表示, 将long中的64个bit位划分成了四个部分. 用来标识已经分配的空间或者空置的空间.
       >
       >   - 各个部分的信息:
       >
       >     |     Bit 位     |                    源码标识                    |       含义       |
       >     | :------------: | :--------------------------------------------: | :--------------: |
       >     | 0-31, 共 32bit | bitmapIdx of subpage, zero if it's not subpage |    房间标号,     |
       >     |  32, 共 1bit   |                   isSubpage                    |  是否是共享区域  |
       >     |  33, 共 1bit   |                     isUsed                     |   是否已经分配   |
       >     | 34-48, 共15bit |                number of pages                 | 连续的房间有几间 |
       >     | 49-63, 共15bit |            page offset in the chunk            |   从第几间开始   |
       >
       >   - 例如: 
       >
       >     |                            handle                            |                             说明                             |
       >     | :----------------------------------------------------------: | :----------------------------------------------------------: |
       >     | 0{11}_**0000** - 0{11}\_**0100** - **10** - 0{24}\_0000\_0000 | 0{11}\_**0000** -- 从第0个房间开始, 0{11}\_**0100** -- 连续4个房间, <br />**10** -- 处于使用状态, 独立区域. |
       >     | 0{11}\_**0100** - 0{11}_**0010** - **00** - 0{24}\_0000\_0000 | 0{11}\_**0100** -- 从第4个房间开始, 0{11}\_**0010** -- 连续2个房间, <br />**00** -- 处于空置状态. |
       >     | 0{11}\_**1001** - 0{11}_**0001** - **11** - 0{24}\_**0100\_0001** | 0{11}\_**1001** -- 从第9个房间开始, 0{11}\_**0001** -- 连续1个房间, <br />**11** -- 处于使用状态, 共享区域, 共享区域中的第1排第一个座位. |
       >     | 0{11}_**0001_0101** - 000\_**0111_1110_1011** - **00** - 0{32} | 0{11}_**0001_0101** -- 从第21个房间开始, 000\_**0111_1110_1011** -- 连续2027个房间, <br />**00** -- 处于空置状态. |
       
    2. ##### 管理信息: 
    
       > - 图中标号: **101**, 将真正分配的内存空间(<u>memory</u>)按房间进行划分, 每一个房间给一个门牌号, 从0开始, 默认是到2047号.
       >
       > - 图中标号: **102**, <u>runsAvail</u>中存放连续房间的信息. 先根据连续房间的个数查找对应的runsAvail的index下标, 然后将描述这个区域的handle值放在index下标对应的*LongPriorityQueue*中.
       >
       >   - <u>runsAvail</u>每个index对应的连续房间数(pages)是一个区间(range), 
       >
       >     | runsAvail index | 对应连续pages, 表示最小有多少个连续房间. |
       >     | :-------------: | :--------------------------------------: |
       >     |        3        |             pages >= 4 & < 5             |
       >     |        8        |            pages >= 10 & < 12            |
       >     |       38        |          pages >= 1792 & < 2048          |
       >     |       39        |               pages = 2048               |
       >
       >   - <u>runsAvail</u>只存放空置房间的信息, 按连续房间的大小, 对应存放在index下标对应的*LongPriorityQueue*中. 例如图中: 已经<u>占用</u>的房间分别是: <u>0 - 3</u> -- 分配成<u>独立</u>区域. 房间 <u>6, 9, 12, 18</u> 被分配为<u>共享</u>区域.空置的房间**4-5**, **7-8**, **10-11**, **19-2047** .
       >
       >     |       空置房间(起 止)       | 空置房间数 | 对应的runsAvail.index |                    handle标识                     |
       >     | :-------------------------: | :--------: | :-------------------: | :-----------------------------------------------: |
       >     |  4 - 5, 图中标号: **103**   |     2      |           1           |       0{11}\_0100 - 0{11}_0010 - 00 - 0{32}       |
       >     |  7 - 8, 图中标号: **103**   |     2      |           1           |       0{11}\_0111 - 0{11}_0010 - 00 - 0{32}       |
       >     | 10 - 11, 图中标号: **103**  |     2      |           1           |       0{11}\_1010 - 0{11}_0010 - 00 - 0{32}       |
       >     |  13-17, 图中标号: **104**   |     5      |           4           |       0{11}\_1101 - 0{11}_0101 - 00 - 0{32}       |
       >     | 21 -2047, 图中标号: **105** |    2027    |          38           | 0{11}_0001_0101 - 000_0111_1110_1011 - 00 - 0{32} |
       >
       > 
       >
       > 3. 图中标号: **106**, <u>runsAvailMap</u>: *LongLongHashMap* 存放的是空置空间的起止信息. 例如:
       >
       >    | Key  |                         Key 说明                         |                Value -- handle信息                |
       >    | :--: | :------------------------------------------------------: | :-----------------------------------------------: |
       >    |  4   |    图中标号: **107**, 空置空间 4 - 5, 从门牌号: 4开始    |       0{11}\_0100 - 0{11}_0010 - 00 - 0{32}       |
       >    |  5   |    图中标号: **108**, 空置空间 4 - 5, 到门牌号: 5结束    |       0{11}\_0100 - 0{11}_0010 - 00 - 0{32}       |
       >    |      |                                                          |                                                   |
       >    |  21  | 图中标号: **109**, 空置空间 21 -2047, 从门牌号: 21个开始 | 0{11}_0001_0101 - 000_0111_1110_1011 - 00 - 0{32} |
       >    | 2047 | 图中标号: **110**, 空置空间 21 -2047, 到门牌号: 2047结束 | 0{11}_0001_0101 - 000_0111_1110_1011 - 00 - 0{32} |
       >
       >    注: runsAvailMap的一个应用场景是查找与当前的区域相临的区域是空置还是已经分配的, 用在区域中.
       >
       > 4. 图中标号: **111**, subpages: PoolSubpage[2048], 这里按房间的个数来初始化数组, 实际上可能有很多个下标对应的null值. 当一个共享区域(*PoolSubpage*)被分配时, 可能是多个房间划分到这个共享区域下, 共享区域开始于那个门牌号, 那么就存放在门牌号对应的index下标下. 例如:
       >
       >    | <u>subpages</u>.index |                     对应共享区域                      |             *PoolSubpage*             |
       >    | :-------------------: | :---------------------------------------------------: | :-----------------------------------: |
       >    |           6           |  图中标号: **112**, 共享区域 6 - 6, 从门牌号: 6开始   |    每个elemSize为32, 共享区域为8K     |
       >    |           9           |  图中标号: **113**, 共享区域 9 - 9, 从门牌号: 9开始   |   每个elemSize为1024, 共享区域为8K    |
       >    |          18           | 图中标号: **114**, 共享区域 18 - 20, 从门牌号: 18开始 | 每个elemSize为1024 * 3, 共享区域为24K |
       >
    
3. 实现的方法:

    1. 

[TOC]

